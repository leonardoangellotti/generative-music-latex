
\documentclass[a4paper,12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{float}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{subcaption}


% Definire un nuovo colore verde scuro
\definecolor{darkgreen}{rgb}{0,0.5,0}

\lstset{
    basicstyle=\ttfamily\small,  
    basicstyle=\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{darkgreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)}
}

% Per il titolo
\title{Titolo della Tesi}
\author{Nome dell'Autore}
\date{Anno Accademico 2023/2024}

% Inizio del documento
\begin{document}

% Pagina del titolo
\begin{titlepage}
    \begin{center}
        \includegraphics[width=0.15\textwidth]{units_sigillo.png} 
        \vspace{1cm}
        
        \textsc{\LARGE Università degli studi di Trieste}\\[1.5cm]
        
        \textsc{\Large Dipartimento di Matematica e Geoscienze}\\[0.5cm]
        
        \textsc{\large Intelligenza Artificiale e Data Science}\\[0.5cm]
        
        \vspace{2cm}
        
        % Titolo
        { \huge \bfseries Musica Genetica \\[0.4cm] }
        
        \vspace{2cm}
        
        \begin{minipage}{0.4\textwidth}
            \begin{flushleft} \large
                \emph{Autore:}\\
                Leonardo Angellotti
            \end{flushleft}
        \end{minipage}
        \begin{minipage}{0.4\textwidth}
            \begin{flushright} \large
                \emph{Relatore:} \\
                Luca Manzoni
            \end{flushright}
        \end{minipage}
        
        \vfill
        
        {\large Anno Accademico 2023/2024}
        
    \end{center}
\end{titlepage}

\tableofcontents

\chapter{Introduzione}

\begin{quote}
\centering
\small
C’è una grande differenza tra \textit{impossibile} e \textit{difficile da immaginare}. \\
La prima riguarda il \textit{problema}; la seconda riguarda \textit{te}.

\end{quote}

La Musica Algoritmica ha una lunga storia nell'era pre-informatica, dai lavori 'processuali' di \href{https://youtu.be/UT5lgaE-qZY}{George Brecht (Drip Music, 1962)}, \href{https://youtu.be/pxs35GrZVAs}{Stockhausen (Setz die Segel zur Sonn, 1970)}, \href{https://youtu.be/SZazYFchLRI}{Xenakis (Metastaseis, 1971)} fino a \href{https://youtu.be/o9UsLbsdA6s}{George Lewis (Voyager, 1993)}. \\

Gli algoritmi di Intelligenza Artificiale (AI) sono una delle tecnologie più ampiamente utilizzate e potenti del ventunesimo secolo. Sebbene la definizione esatta di AI si sia costantemente evoluta, dagli anni '50 di Alan Turing, alle attuali architetture di Deep Learning come Alpha Go, 
rimane fisso il fatto che i correnti modelli dedicati ad attività creative, sono attualmente agli albori, e si sviluppano quasi esclusivamente il dataset su cui sono addestrati. \\
Un altro limite è di carattere \textit{filosofico}, infatti l'approccio adottato da tali modelli tratta il processo creativo come un problema di ottimizzazione (non come l'artista, nella sua necessità a creare). \\ 

Esistono comunque progetti dove le composizioni che rispettano una certa simmetria e regolarità, come i \href{https://youtu.be/QiBM7-5hA6o}{corali di Bach (Deep Bach)} o la \href{https://folkrnn.org}{Modellazione della Musica Popolare (Folk RNN)}. \\
\\
Modellare la musica è un problema difficile per due ragioni principali: \\
\\
Le gerarchie semantiche sono complesse, soggettive e operano su più scale temporali (dell'ordine di secondi a diversi minuti); \\
\\
Le rappresentazioni audio a frequenze di campionamento dell'udito umano, rendono le sequenze da modellare diuturne, una tipica canzone di 4 minuti in qualità CD (44 kHz, 16-bit) conterrebbe oltre 10 milioni di \textit{timesteps}. \\
\\
I progetti \href{https://magenta.tensorflow.org }{Magenta di Google} (2016 - 2020), \href{https://openai.com/index/musenet/}{MuseNet di OpenAI} (2019), \href{https://www.flow-machines.com}{Flow Machines di Sony CSL} (2012), il \href{https://ai.meta.com/research/publications/a-universal-music-translation-network/}{Universal Music Translator di Facebook AI Research} (2019) e \href{https://aws.amazon.com/it/deepcomposer/}{Deep Composer di Amazon} (2019)
sono alcuni degli sforzi operati dalle grandi aziende tecnologiche, potendo queste far ricorso ad ampi dataset per il training dei modelli. \\ 
\\
Tuttavia i metodi attuali risultano \textit{rigidi}, la generazione dipende fortemente l'architettura fissata al momento dell'addestramento. \\
(Una rete neurale allenata da un dataset di canzoni pop, non è in grado di generare una melodia blues). \\
\\
\textbf{Struttura della tesi} \\
\\
Nella testi vengono riportate inizialmente le nozioni di base utili alla comprensione degli argomenti trattati. \\
Vengono poi discussi i principali metodi di generazione musicale correnti, e gli studi associati. \\
Infine viene presentato un algoritmo genetico, per la generazione di una sequenza musicale, discutendone i risultati conseguiti. \\

\chapter{Nozioni di Base}

\section{nozioni algoritmiche}

\subsection{fitness-function}

La fitness function fornisce un punteggio numerico che rappresenta l'efficacia di una soluzione candidata. \\
Questo punteggio guida l'algoritmo nel processo di selezione e ottimizzazione. \\
L'obiettivo è massimizzare o minimizzare la fitness function, a seconda del problema. \\
Negli algoritmi genetici, le soluzioni con punteggi di fitness più alti (\textit{genitori}) hanno una probabilità maggiore di essere selezionate per la riproduzione e la generazione di nuove soluzioni (\textit{prole}).

\subsection{modello markoviano}

In un modello markoviano, un nuovo stato dipende esclusivamente dallo stato corrente, senza tener conto degli stati passati. \\
Formalmente, questa proprietà si esprime come: \\
\[
P(X_{n+1} = x \mid X_n = x_n, X_{n-1} = x_{n-1}, \ldots, X_0 = x_0) = P(X_{n+1} = x \mid X_n = x_n)
\]
\\
Dove $X_i$ rappresenta lo stato del sistema al tempo $i$. \\
Il modello è costituito da un insieme finito e numerabile di stati. Le probabilità di transizioni tra stati possono essere rappresentate in una matrice. \\
Per una catena di Markov con $N$ stati, la matrice di transizione $P$ è una matrice $N×N$ dove l'elemento $P_{ij}$ rappresenta la probabilità di transizione dallo stato $i$ allo stato $j$. \\
Le righe della matrice devono sommare a $1$: \\
\[
\sum_{j=1}^{N} P_{ij} = 1
\]
\\
Un modello markoviano raggiunge una distribuzione stazionaria, quando le probabilità di transizione non mutano nel tempo, convergendo ad un punto di equilibrio. \\
Nel caso specifico della tesi questo approccio è adottato per generare una consecuzione di note e accordi.

\subsection{artificial neural network}

Una Artificial Neural Network (ANN), o rete neurale artificiale, è un modello computazionale ispirato alla struttura e al funzionamento del cervello umano, progettato per riconoscere schemi complessi e prendere decisioni basate su input di dati. \\
Le ANNs sono particolarmente utili in vari campi dell'intelligenza artificiale, come il riconoscimento di immagini, il riconoscimento vocale, l'elaborazione del linguaggio naturale ed altri. \\
\\
\textbf{Funzionamento di una ANN} \\
\\
\textbf{Forward Propagation}: gli input vengono trasmessi attraverso i vari strati della rete, moltiplicando i valori in input per i pesi delle connessioni e applicando una funzione di attivazione. Questo processo persegue fino a raggiungere il livello di output, restituendo una previsione.
\\
\textbf{Backward Propagation}: l'errore tra la previsione e il valore reale viene calcolato e usato dalla rete per aggiornarne i pesi. Viene usato il calcolo del gradiente per minimizzare l'errore, adattando i pesi in modo iterativo.

\subsection{file MIDI}

Un file MIDI (Musical Instrument Digital Interface) è un formato di file standardizzato nella rappresentazione di \textbf{informazioni musicali}. \\
Invece di memorizzare il suono, come i file audio, nel formato MIDI si memorizzano i dati relativi alle note, gli strumenti, alle dinamiche e ad altre istruzioni musicali, che possono essere riprodotte da dispositivi elettronici compatibili, come sintetizzatori, sequencer, computer e software di notazione musicale.

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/midi} 
    \label{fig:immagine6}
\end{figure}

\section{nozioni musicali}

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/music phrase} 
    \caption{generica linea melodica di uno spartito}
    \label{fig:immagine3}
\end{figure}

\subsection{caratteristiche di una nota musicale}

\textbf{Altezza (Pitch):} \\
L'altezza di una nota è la frequenza del suono prodotto, determinando quanto questo sia acuto o grave. \\
Nel pentagramma sono espresse  dalla posizione verticale. \\
Le note musicali fondamentali nell'ottava sono Do(C), Re(D), Mi(E), Fa(F), Sol(G), La(A), Si(B). \\
\\
\textbf{Durata:}\\
La durata di una nota indica per quanto tempo viene suonata. \\
\\
Di seguito un'immagine esemplificativa:

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/note duration} 
    \label{fig:immagine4}
\end{figure}

\textbf{Intensità (Velocity):} \\
L'intensità di una nota si riferisce a quanto \textit{forte} o \textit{piano} viene suonata. \\
Sono indicazioni come \textit{p} (piano) per suonare piano, \textit{f} (forte) per suonare forte, \textit{mf} (mezzo forte), \textit{mp} (mezzo piano), e altre variazioni come crescendo (aumentando l'intensità) e decrescendo (diminuendo l'intensità).

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/dynamics} 
    \label{fig:immagine5}
\end{figure}

\subsection{scala armonica}

La scala maggiore è una tra le più comuni e ha un suono generalmente percepito come \textit{felice} e \textit{luminoso}. \\
La scala maggiore segue uno schema specifico di toni (T) e semitoni (S). Lo schema è: \\
\texttt{T-T-S-T-T-T-S} \\
Ad esempio, la scala di Do maggiore è: \\
\texttt{Do(C)-Re(D)-Mi(E)-Fa(F)-Sol(G)-La(A)-Si(B)-Do(C)} 

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/scala} 
    \label{fig:immagine13}
\end{figure}

La scala minore ha un suono generalmente percepito come \textit{triste} o \textit{scuro}.  \\
Segue uno schema diverso: \\
\texttt{T-S-T-T-S-T-T} \\
Ad esempio, la scala di La minore naturale è: \\
\texttt{La(A)-Si(B)-Do(C)-Re(D)-Mi(E)-Fa(F)-Sol(G)-La(A)} 

\subsection{melodia}

Una melodia è una sequenza di note musicali, percepita come un'unità singola e coerente. \\
Essa è una componente fondamentale della musica, essendo spesso la parte più riconoscibile di un brano. \\
Una melodia è composta da una serie di note che vengono suonate in successione. Queste possono variare in altezza (pitch), durata (rhythm), intensità (velocity). \\
Il \textbf{contorno melodico} si riferisce al profilo delle altezze, ovvero come le note \textit{ascendono} e \textit{calano} nel corso della melodia. Questo può includere salti, scale, ripetizioni e altre variazioni. \\
La melodia è spesso \textbf{basata su una scala musicale}, come una scala maggiore o minore, fornendo un quadro armonico e tonale. 

\subsection{accordi}

Gli accordi sono combinazioni di tre o più note suonate simultaneamente o in sequenza arpeggiata. \\
Gli accordi sono fondamentali nella musica, fornendo la struttura armonica su cui si basano melodie e progressioni. \\
Possono essere maggiori o minori.\\
\\
Un \textbf{problema fondamentale} nella generazione di musica tramite algoritmi, è la \textbf{scelta nella sequenza di una progressione di accordi}, che descrive lo stile musicale di una canzone e la sua \textit{orecchiabilità}. \\
\\
Esempi di Progressioni di Accordi usati comunemente in musica:\\
\\
Progressione \texttt{I-IV-V-I} in Do Maggiore: \\
Accordi: \texttt{Do(C)-Fa(F)-Sol(G)-Do(C)} \\
Uso comune nelle canzoni pop e rock (\textit{il giro di Do}) \\
\\
Progressione \texttt{ii-V-I} in Jazz: \\
Accordi: \texttt{Re min.settima(Dm7)-Sol settima(G7)-Do mag.settima(Cmaj7)} \\

\chapter{Metodi di generazione}

\section{generazione melodia}

Quando si considera il problema della generazione musicale, la forma più semplice di esercizio è la composizione di \textbf{melodie monofoniche}.\\
I sistemi generativi dipendono da una \textit{fitness-function} che valuta le sequenze generate.\\
Tale funzione di fitness è spesso basata sulla somiglianza con un determinato corpus, stile o brano, o dipende in generale dalle regole teoriche musicali.\\
\\
I primi tentativi di generare melodie con i computer risalgono al 1956, quando \textbf{Pinkerton} costruì un \textit{modello markoviano} , il \textbf{Banal Tune-Maker}, basato su un corpus di 39 semplici filastrocche, tuttavia il modello tendeva ad essere ripetitivo.

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/banal tune maker} 
    \label{fig:immagine13}
\end{figure}

Un altro problema nell'uso delle catene di Markov, risiede nell'eccessiva somiglianza con la melodia originale. \\
Il compromesso tra la composizione di brani simili a lavori esistenti, contro la necessità di doverne creare di nuovi e creativi, è difficile da ricercare. \\
Si ricorda a tal proposito una citazione di Stravinsky, celebre compositore Russo: \\
\textit{“i buoni compositori copiano, i grandi compositori rubano”}.\\
Riferendosi a quest'idea tuttavia le macchine non hanno ancora la capacità di distinguere tra il furto astuto e il plagio totale. \\
Con quest'intuizione è stata poi introdotta la variabile \textit{MaxOrder}, ad indicare il massimo ordine di sottosequenze simili consentito in una sequenza generata, con l'intento di limitare le ripetizioni eccessive nel materiale. \\
Esistono diverse tipologie di tali vincoli di controllo, ad esempio la volontà che una sequenza sia globalmente ascendente, o che segua invece un intorno di note arbitrario. \\
\\
\textbf{Davismoon ed Eccles} (2010) sono stati alcuni dei primi ricercatori a inquadrare la generazione musicale come un problema di ottimizzazione in un modello di Markov.  \\
Per valutare la musica generata, il loro sistema costruisce un secondo modello, riducendo poi al minimo la distanza euclidea tra quello originale e il nuovo.  \\
Lo studio si è basato sulle composizioni melodiche tipiche dei \textit{bagana} (molto semplici e ripetitive), una lira a dieci corde suonata dagli Amhara, abitanti dell'Etiopia centrale e settentrionale.

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/bagana} 
    \label{fig:immagine14}
\end{figure}

Comporre una melodia monofonica può sembrare un compito semplice rispetto alla partitura di un'intera sinfonia. \\
Tuttavia, le melodie sono più che semplici movimenti tra le note, normalmente possiedono una \textbf{struttura a lungo termine}. \\
Negli ultimi anni, alcune ricerche hanno dimostrato l’efficacia dell’utilizzo di tecniche come il \textbf{deep learning e ANN} per rafforzare una consecuzione coerente. \\
\\
Sebbene esista molto lavoro sulla generazione di accordi data una melodia, alcuni si concentrano viceversa, sulla generazione di una melodia che si adatti a una sequenza di accordi. \\
\\
\textbf{Moorer} (1972), ad esempio ha adottato quest'ultimo approccio. \\
Le note della melodia sono limitate solo a quelle dell'accordo corrispondente in un dato momento. \\
Ad ogni punto si decide, sulla base di un modello markoviano, di invertire i frammenti melodici basati sull'accordo, oppure di copiarne da quello precedente. \\
Le brevi melodie risultanti tuttavia hanno un suono estraneo, l'approccio melodico non è quello utilizzato dagli esseri umani, non discriminando le sequenze \textit{gradevoli} da quelle \textit{non familiari}. 

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/moorer} 
    \caption{James A. Moorer con il Lucasfilm Audio Signal Processor.}
    \label{fig:immagine15}
\end{figure}

\subsection{armonia}

L'armonia è definita da una relazione verticale tra note, suonate simultaneamente, e orizzontale, la loro relazione nel tempo. \\
Il sistema deve generare sequenze riconoscibili nel genere musicale, senza mai essere \textit{sostanzialmente uguali} a gli esempi di riferimento. \\
\\
La maggior parte degli studi adotta approcci basati su un training\_set per determinare possibili accordi in un dato segmento melodico, garantendo una corretta transizione tra questi. \\
\\
\textbf{Steedman} (1984) studiando melodie blues con lunghezza di 12 battute, e definendo un piccolo insieme di regole, è riuscito a produrre progressioni di accordi tipiche dello stile. 

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/seedman} 
    \label{fig:immagine16}
\end{figure}

\textbf{Lee e Jang} (2004) hanno utilizzato il modello di Markov, integrato con programmazione dinamica, per determinare il pattern armonico di una melodia canticchiata da un utente; \\
le probabilità nella matrice di transizione, tra le note correnti, sono state apprese da un set di 150 canzoni. \\
\\
\textbf{Simon} (2008) ha adottato un approccio simile; allenando il proprio sistema su 298 brani di vari generi come jazz, rock, pop, blues ed altri. \\
\\
Questi ultimi due sistemi vengono valutati tramite \textbf{feedback soggettivo}, cioè da un umano e non da una qualche fitness-function, a seguito di sessioni d'ascolto. \\
Uno svantaggio di questo approccio è che le sequenze di accordi generate tendono ad essere \textbf{generiche e indistinte nello stile}. \\
\\
L'uso dell'uomo come funzione di fitness è certamente valido, ma costringe a delle forti limitazioni: \\
se si vuole valutare immagini, queste possono essere visualizzate contemporaneamente, e molto rapidamente, 
mentre la musica è un fenomeno temporale, e quindi tutti i campioni devono essere ascoltati in sequenza, uno dopo l'altro. \\
Ciò si traduce in un costo \textit{computazionale} elevato:

\subsection{ritmo}

Nei sistemi di generazione musicale il ritmo dipende dalla durata di ciascuna nota. \\
In generale, esistono meno sistemi di \textit{generazione ritmica} rispetto ai sistemi melodici. \\
\\
\textbf{Tokui e Iba} (2000) hanno proposto il sistema CONGA, che usa algoritmi genetici per produrre sequenze ritmiche, usando l'utente come funzione fitness. \\
Brevi frammenti di schemi ritmici formano gli elementi cromosomici nell'algoritmo; subendo poi trasformazioni come il crossover e mutazioni. 

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \begin{minipage}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/conga 1}
        \label{fig:image1}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/conga 2}
        \label{fig:image2}
    \end{minipage}
\end{figure}

\textbf{Ariza} (2002), ha generato ritmiche derivanti da variazioni genetiche di un dataset, ma la funzione fitness è consistita nel calcolare la distanza tra la generazione e l'originale, attraverso differenti misure di distanza. 

\section{algoritmo genetico}

\subsection{musica evolutiva}

L'applicazione dei metodi di \textit{computazione evolutiva} nel campo musicale ha cominciato ad emergere all'inizio degli anni '90. \\
Ci sono tre criteri fondamentali da considerare: \\
\textit{il domino del problema,} \\
\textit{la rappresentazione individuale} \\
\textit{e la misura dell'idoneità}. \\
\\
Nella ricerca è fondamentale la codifica del dominio, e quindi i limiti o lo stile musicale, entro cui l'algoritmo ricerca. \\
Si definisce esattamente quale tipo di \textit{musica} si desidera sviluppare; si è intenzionati a creare melodie, armonizzazioni o progressioni di accordi? \\
\\
Nella rappresentazione individuale ci si chiede come rappresentare la musica: audio, spartiti stampati, messaggi MIDI? \\
Comunemente, per una più facile gestione dei dati, si ricorre al formato MIDI, dove il genoma contiene valori di pitch e durate. \\
\\
Infine la questione della misura di idoneità: supponendo che due individui rappresentino brani musicali nel dominio desiderato, cosa rende uno \textit{migliore} dell’altro? 

\subsection{prime applicazioni degli alg. gen. alla musica}

\textbf{Horner e Goldberg} furono tra i primi ad applicare un algoritmo genetico al processo di composizione musicale considerando il problema della \textit{transizione tematica}. \\
È stata considerata la trasformazione di una frase melodica in un'altra, dove i genomi rappresentavano la serie di transizioni necessarie.  \\
La fitness-function misurava quanto bene il modello finale corrispondesse al modello desiderato. \\
Il sistema tuttavia è stato utilizzato per creare \textit{transizioni}, piuttosto di creare effettivamente nuova musica. 

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/Horner e Goldberg} 
    \caption{schema del processo usato da Horner e Goldberg}
    \label{fig:immagine17}
\end{figure}

\textbf{John Biles} ha creato il sistema GenJam che utilizza un algoritmo genetico per evolvere assoli jazz. \\
GenJam ha utilizzato due popolazioni indipendenti: una per le misure di fitness ed una per la generazione di sequenze. \\
Questo ha permesso una valutazione dei fraseggi \textbf{in tempo reale}, valutandoli come \textit{buoni} o \textit{cattivi}, permettendo a Biles di suonare la sua tromba accompagnato dall'algoritmo. 

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/GenJam} 
    \caption{John Biles suona assieme a GenJam}
    \label{fig:immagine7}
\end{figure}

In studi successivi, si è \textbf{addestrata una ANN a fungere da funzione di fitness}, eliminando così la necessità dell'ascoltatore umano. \\
Tuttavia, si è riscontrato che i \textbf{risultati non erano comunque soddisfacenti}, stabilendo che gli esseri umani ascoltano e sperimentano la musica in modi complessi e sottili, che non possono colti da modelli statistici come le ANN. \\

In uno studio che ha fatto uso di ANN come fitness-function, gli autori hanno limitato il loro dominio, considerando solo armonie basate su tre accordi nella tonalità di Do maggiore, e creando solo melodie di quattro battute di durata. \\
La composizione è stata poi suddivisa in blocchi, e per ciascuno di questi un algoritmo genetico ha generato una popolazione.
Una ANN addestrata precedentemente da esempi forniti dall'utente, ha quindi giudicato i genomi candidati. \\
Gli autori hanno riconosciuto che questa combinazione di alg. gen. e ANN potrebbe produrre delle pseudo composizioni, 
ma \textbf{le restrizioni applicate al dominio di addestramento hanno limitato fortemente il modello}. \\
\\
In generale si riscontra che, indipendentemente da quanto complessa o sfaccettata sia una data misura di fitness, è sicuramente \textit{impossibile dire di trovare la misura definitiva della musica}. 

\section{L-System}

Gli L-system (o Lindenmayer system) sono un tipo di sistema formale utilizzato per modellare la crescita di \textit{piante ricorsive}. \\
Sono stati introdotti da Aristid Lindenmayer nel 1968 e sono composti da un alfabeto di simboli che, usati assieme ad un set di \textit{regole di produzione}, vengono impiegati per generare stringhe, a loro volta contenenti altri simboli, applicando appunto un approccio ricorsivo. \\
\\
\textbf{Alfabeto:} I simboli dell'alfabeto possono rappresentare note, durate, dinamiche, articolazioni, e altri elementi musicali. \\
\textbf{Assioma:} La stringa iniziale può essere una sequenza di note. \\
\textbf{Le regole} descrivono come trasformare ogni simbolo in una nuova sequenza. \\
\\
Alfabeto: \texttt{A, B} \\
Assioma: \texttt{A} \\
Regole di produzione: \\
  \texttt{A → AB} \\
  \texttt{B → A} \\
\\
In questo esempio: \\
1. Partiamo dall'assioma \texttt{A}. \\
2. Applichiamo le regole: \\
    \texttt{A} diventa \texttt{AB} \\
   \texttt{AB} diventa \texttt{ABA} \\
   \texttt{ABA} diventa \texttt{ABAAB} \\
   e così via. \\
\\
Ora, mappiamo i simboli alle note musicali: \\
\texttt{A = Do} \\
\texttt{B = Re} \\
\\
La sequenza generata può essere interpretata come una melodia: \texttt{Do,Do-Re,Do-Re-Do, \\ Do-Re-Do-Do-Re}, e così via. \\
\\
Gli L-system così permettono di generare pattern musicali ricorsivi e \textbf{auto-simili} che possono essere sia prevedibili ma anche variabili. \\
\\
Nel paper \textit{Growing music}, \textbf{Peter Worth e Susan Stepney}, hanno sperimentato in modo più approfondito questo sistema. \\

Gli L-System permettono una maggiore sensibilità per il \textit{contesto}, cioè il rapporto tra le note lungo la sequenza, 
facendo crescere conseguentemente la pianta in modo diverso in base a gli elementi nell'intorno. \\
Questo potrebbe essere utile in musica, quando ad esempio il pezzo generato potrebbe dover raggiungere un climax o interrompersi bruscamente. \\
Per far sì che questo avvenga, la regola di produzione per un L-System viene applicata al simbolo solo se compare inclusa tra altri specifici. \\
La notazione \texttt{A < B > C} indica che agisce se la stringa \texttt{B} appare con \texttt{A} alla sinistra e \texttt{C} a destra. \\
Viene considerato il seguente L-System \textit{sensibile al contesto}: 

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{/Users/leonardoangellotti/Desktop/tesi latex/immagini/L-system} 
    \label{fig:immagine8}
\end{figure}

Questa melodia, e altre derivate in modo simile, suonano \textit{imprevedibilmente}; ricordando un assolo jazz. \\
Le note non rientrano bene nella cadenza 4/4 in una partitura, perché molte hanno una durata irregolare. \\
Tuttavia la melodia ritorna sempre a un motivo o una frase principale, a volte trasposto o suonato in un punto diverso della battuta. \\
Ad esempio, nella partitura sopra, una serie di note nella prima battuta è ripetuta nella nona, trasposte in avanti per un quarto di tempo e aumentate di 2 semitoni. \\
Questo tipo di simmetria rispecchia la struttura ricorsiva ad albero da cui ha origine. 

\chapter{Progetto di musica genetica}

Viene ora introdotto un progetto di algoritmo genetico utile ad esemplificare fin quanto detto. \\
All'interno del progetto la funzione: \\

% Inserimento di un esempio di codice
\\
\texttt{\small\textcolor{darkgreen}{\# Main function for running all helper functions and handling user input.}} \\
\texttt{\small def genetic-algorithm(key, root, tempo, rhythm)} \\
\\
scrive su disco 10 genotipi di sequenze di note, in formato MIDI, come risultato dell'algoritmo genetico. \\
La funzione prende in input dall'utente: \\
\textbf{la scala} (key) utilizzata nella scelta delle note, può essere \textit{major} o \textit{minor}. \\
\textbf{La nota fondamentale} che indica la tonalità della canzone (root), e sulla quale verrà costruita la scala (es: \texttt{C, C\#, D, D\#, E, F, F\#, G, G\#, A, A\#, B}) \\
\textbf{Il numero di battiti al minuto} (bpm), ovvero la velocità di esecuzione, della composizione \\
\textbf{il ritmo della composizione}, ovvero la durata delle note, a scelta tra quattro predefiniti (\textit{rock, jazz, dance, bossa nova}). \\
\\
All'interno della funzione troviamo \\
\\
\texttt{\small\textcolor{darkgreen}{\# Build the scale based on the root note and chosen scale type}} \\
\texttt{\small scale = buildScale(root, key)} \\
\\
Restituisce un array, dove ogni numero rappresenta il codice MIDI per ogni nota. \\
L'array rappresenta la scala, maggiore o minore, costruita partendo dalla nota fondamentale scelta. \\
Viene eseguita poi l'evoluzione vera e propria, attraverso la crescita del genoma.

\subsection{Run-Evolution}

\texttt{\small\textcolor{darkgreen}{\# Run the genetic algorithm to evolve a melody using the specified mutation rate and scale}} \\
\texttt{\small evolvedMelody = runEvolution(MUTATION\_RATE, scale)} \\
\\
\texttt{runEvolution} implementa un algoritmo genetico che migliora in modo iterativo la popolazione di genomi musicali attraverso selezione, crossover e mutazione, l'esecuzione avviene finché non viene raggiunto un genoma con il punteggio \texttt{MAX-FITNESS} specificato, o il numero massimo di generazioni consentito, \texttt{MAX\_GENERATIONS}. \\
Viene inizialmente creata un popolazione, inizializzata con metodo random. La popolazione è composta da 10 genomi. \\
Ogni genoma è un elenco di 8 battute, ciascuna contenente 8 note, tutte scelte casualmente dalla scala specificata. \\
Il codice che segue rappresenta lo sviluppo dell'algoritmo genetico utilizzato. \\
\\
\texttt{\small\textcolor{darkgreen}{\# Iterate for a maximum number of generations}} \\
\texttt{\small for \_ in range(MAX\_GENERATIONS):} \\

\indent        \texttt{\small\textcolor{darkgreen}{\# Sort the population based on fitness scores in descending order}} \\
\indent        \texttt{\small population = sorted(population, key=fitnessFunction, reverse=True)} \\
        
\indent        \texttt{\small\textcolor{darkgreen}{\# Select the top 2 genomes (the fittest) to carry over to the next generation}} \\
\indent        \texttt{\small nextGeneration = population[:2]} \\

\indent        \texttt{\small\textcolor{darkgreen}{\# Generate the rest of the next generation through crossover and mutation}} \\
\indent        \texttt{\small for \_ in range(len(population) // 2 - 1):} \\

\indent\indent            \texttt{\small\textcolor{darkgreen}{\# Select two parent genomes based on their fitness}} \\
\indent\indent            \texttt{\small parentA, parentB = selectParents(population)} \\
\indent\indent            \texttt{\small\textcolor{darkgreen}{\# Perform crossover to produce two child genomes}} \\
\indent\indent            \texttt{\small childA, childB = multipointCrossover(parentA, parentB)} \\
\indent\indent            \texttt{\small\textcolor{darkgreen}{\# Mutate the child genomes and add them to the next generation}} \\
\indent\indent            \texttt{\small nextGeneration += [mutateGenome(childA, mutationRate, scale),} \\
\indent\indent            \texttt{\small mutateGenome(childB, mutationRate, scale)]} \\

\indent        \texttt{\small\textcolor{darkgreen}{\# Update the population with the new generation}} \\
\indent        \texttt{\small population = nextGeneration} \\
        
Per un numero massimo di generazioni prefissato, vengono create popolazioni di genomi. \\
Successivamente alla prima inizializzazione randomica, viene applicata la Fitness-Function, che assegna ad ogni genoma un peso/punteggio basandosi sui propri criteri di valutazione (vedremo in seguito). \\
Nella successiva popolazione vengono mantenuti i primi due genomi con il punteggio più alto, mentre per i restanti 8 vengono selezionati di volta in volta due genitori, da cui, attraverso un (multipoint) crossover, danno luogo a due figli, i quali subiscono una fase di mutazione. \\
I processi di crossover e mutazione sono definiti di \textit{exploration}, perché servono ad esplorare soluzioni che i due migliori genomi non sono riusciti ad ottenere. \\
Viceversa i due genomi mantenuti con il punteggio più alto, che si tramandano da una popolazione alla successiva, servono a garantire la migliore performance ad ogni generazione, qualora i genomi di exploration non diano risultati soddisfacenti. \\
Quando avviene che in una popolazione, i figli generati ottengano un punteggio superiore ai due migliori correnti, questi vengono dunque sostituiti. \\
Al termine del processo, viene scritta su disco l'ultima popolazione costituita da 10 genomi. \\
Il migliore tra questi (con punteggio più alto) viene chiamato \texttt{best\_genome.mid}. 

\subsection{fitness-function}

La fitness function calcola il punteggio finale ponderando e sommando i punteggi dei componenti per \textbf{fluidità, ritmo e armonia}, restituendo il risultato. \\
Vengono inizializzati i pesi e i punteggi. \\
\\
\texttt{\small\textcolor{darkgreen}{\# Weights for the different fitness components}} \\
    \texttt{\small smoothnessWeight = 15} \\
    \texttt{\small restWeight = 5} \\
    \texttt{\small harmonyWeight = 20} \\
\\
\texttt{\small\textcolor{darkgreen}{\# Initialize fitness scores}} \\
    \texttt{\small smoothnessScore = 0} \\
    \texttt{\small restScore = 0} \\
    \texttt{\small harmonyScore = 0} \\
\\
L' \texttt{harmonyscore} riporta il punteggio di armonizzazione tra le note, ovvero come queste suonino \textit{bene} tra loro. \\
Di seguito un dizionario in cui troviamo come chiave, la distanza tra la nota corrente e la precedente, e come valore, il punteggio assegnato a tale distanza armonica. \\

\texttt{\small\textcolor{darkgreen}{\# Harmony intervals table for scoring harmony}} \\
\texttt{\small harmonyIntervalsTable = \{0: -20, 1: 5, 2: 5, 3: 50, 4: 50, 5: 30, 6: -10, 7: 50, 8: 10, 9: 40, 10: -2, 11: -2, 12: 10, 13: -5, 14: 5, 15: 5, 16: 50, 17: 50, 18: 30, 19: -10, 20: 50, 21: 10, 22: 40, 23: -2, 24: -2, 25: 10\}} \\

- Intervalli consonanti perfetti (0, 7, 12, 19, 24 semitoni): Questi intervalli, che corrispondono alle ottave e quinte perfette (e le loro ripetizioni all'ottava superiore), hanno punteggi molto alti (50 o 10), ad indicare di essere \textit{armoniosi}. \\
    - 0 (Unisono): 50 \\
    - 7 (Quinta giusta): 50 \\
    - 12 (Ottava giusta): 10 \\
    - 19 (Unisono all'ottava superiore): -10 \\
    - 24 (Due ottave giuste): 10 \\
\\
- Intervalli consonanti maggiori (4, 9, 16, 21 semitoni): Questi includono la terza maggiore e la sesta maggiore, che sono generalmente considerati molto armoniosi. \\
- Intervalli consonanti minori (3, 8, 17, 22 semitoni): Questi includono la terza minore e la sesta minore. \\
\\
- Intervalli dissonanti (1, 2, 6, 10, 11, 13, 23 semitoni): Questi includono la seconda minore, la settima minore e la settima maggiore, che sono considerati meno armoniosi o dissonanti. \\
    - 1 (Seconda minore): 5 \\
    - 2 (Seconda maggiore): 5 \\
    - 6 (Tritono): -10 \\
    - 10 (Settima minore): -2 \\
    - 11 (Settima maggiore): -2 \\
    - 13 (Ottava aumentata): -5 \\
    - 23 (Nona aumentata): -2 \\
\\
\textbf{Calcolo del punteggio di fluidità (\texttt{smoothnessScore})}: \\
Se la differenza tra le note (\texttt{noteDifference}) è 0 (unisono), il punteggio di fluidità viene diviso per 10, penalizzando fortemente la ripetizione della stessa nota. \\
Se la differenza è minore o uguale a 2 semitoni, aumenta il punteggio di fluidità di 1, incentivando piccoli movimenti tra le note. \\
Se la differenza è di 11 semitoni (quasi un'ottava), il punteggio di fluidità viene diviso per 2, penalizzando questo ampio intervallo. \\
Per altri intervalli, il punteggio di fluidità aumenta di \texttt{1 / noteDifference}, favorendo movimenti più piccoli tra le note. \\
\\
\texttt{\small if note is None and prevNote is None:} \\
\indent \texttt{\small consecutiveRests += 1} \\
\\
Se entrambe \texttt{note} e \texttt{prevNote} sono \texttt{None}, significa che si è verificata una pausa consecutiva: Incrementa il contatore \texttt{consecutiveRests}. \\
\\
\texttt{\small if numRests * 10 <= len(flatten(genome)):} \\
\indent \texttt{\small restScore += 10} \\
\\
Se il numero di pause (\texttt{numRests}) moltiplicato per 10 è inferiore o uguale alla lunghezza della sequenza musicale (\texttt{flatten(genome)}), aumenta il punteggio ritmico (\texttt{restScore}) di 10. \\
Questo premia una quantità ragionevole di pause nel contesto della lunghezza totale del genoma musicale, suggerendo che alcune pause sono considerate musicalmente desiderabili. \\
\\
\texttt{\small if consecutiveRests:} \\
\indent \texttt{\small restScore -= (consecutiveRests * 10)} \\
\\
Se ci sono pause consecutive (\texttt{consecutiveRests > 0}), penalizza il punteggio ritmico diminuendo \texttt{restScore} di \texttt{consecutiveRests * 10}. \\
Questo penalizza pesantemente le pause consecutive, suggerendo che una lunga serie è considerata indesiderabile dal punto di vista ritmico. \\
\\
\texttt{\small fitness\_weight\_genome = (smoothnessScore * smoothnessWeight) + (restScore * restWeight) + (harmonyScore * harmonyWeight)} \\
\\
Il punteggio di fitness finale (\texttt{fitness\_weight\_genome}) è calcolato come la somma ponderata dei punteggi ottenuti. \\
Ogni punteggio componente (\texttt{smoothnessScore, restScore, harmonyScore}) viene moltiplicato per il rispettivo peso (\texttt{smoothnessWeight, restWeight, harmonyWeight}). \\
La somma dei prodotti risultanti rappresenta il punteggio di fitness finale del genoma. \\
\\
I pesi (\texttt{smoothnessWeight, restWeight, harmonyWeight}) permettono di enfatizzare o de-enfatizzare specifici aspetti della valutazione a seconda degli obiettivi desiderati per la composizione musicale. \\
Ad esempio, aumentando il peso della fluidità, si darà maggiore importanza alle transizioni tra le note, mentre aumentando il peso dell'armonia, si enfatizzerà la qualità armonica della melodia. 

\subsection{risultati}

Eseguiamo dunque il programma. \\
Sono riportati le opzioni scelte per una generazione musicale esemplificativa.

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{/Users/leonardoangellotti/Desktop/università/terzo anno/tesi/MusicGeneticAlgorithm-main/genetic_music/final results rock/results/setting} 
    \label{fig:immagine9}
\end{figure}

Al termine dell'esecuzione vengono stampati i risultati dei punteggi ottenuti dalla fitness function per i genomi di ogni popolazione.

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{/Users/leonardoangellotti/Desktop/università/terzo anno/tesi/MusicGeneticAlgorithm-main/genetic_music/final results rock/results/scores} 
    \label{fig:immagine10}
\end{figure}

Le linee che si mantengono costanti sono i punteggi dei primi due genomi (con punteggio più alto ad ogni generazione) che nell'algoritmo scelto vengono tramandati senza alcuna alterazione (crossover, mutation). \\
Quando \textit{nasce} un nuovo genoma che si verifica avere un punteggio più alto dei primi due, questo fissa un nuovo livello di punteggio, superiore ai precedenti, che viene mantenuto finché ciò non accade nuovamente. \\
Questa procedura garantisce un costante aumento del punteggio e un conseguente miglioramento tra le popolazioni. \\
La nuvola di punti che appaiono al di sotto, con punteggio inferiore, descrive il set di genomi soggetti a crossover e mutazioni. \\
Al termine della procedura evolutiva, vengono stampati i 10 genomi appartenenti all'ultima popolazione. (Le note nella stampa hanno durata unitaria)

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{/Users/leonardoangellotti/Desktop/università/terzo anno/tesi/MusicGeneticAlgorithm-main/genetic_music/final results rock/results/MIDI} 
    \label{fig:immagine11}
\end{figure}

La stampa rappresenta 10 file midi, dal \textit{migliore} (numero 0) al \textit{peggiore} (numero 9) secondo la nostra fitness-function. \\
Le note sono rappresentate dalle linee orizzontali che appaiono a diverse altezze di pitch, indicati nell'asse delle ordinate. \\
Le note sono sequenziali, appaiono dunque in momenti consecutivi. \\
Si ricorda che l'algoritmo genera una sequenza monofonica, infatti non appare più di una nota contemporaneamente. \\
Le sequenze vengono salvate su disco. \\
Il genoma migliore prende il nome di \texttt{best-genome.mid}, mentre ai restanti viene assegnato un numero in ordine decrescente in punteggio (\texttt{genome-0.mid}, ..., \texttt{genome-8.mid}). \\
\\
Ad un primo ascolto di \texttt{best-genome.mid}, percepiamo un movimento coerente nella teoria, ordinato nel ritmo, ma \textit{non armonioso} nel tempo. \\
Non viene percepita infatti alcuna vera struttura compositiva, questo perché la fitness function si è preoccupata di fare confronti solo tra una nota e la precedente, e non tra tutte quelle nella sequenza. \\
Non esiste dunque una vera struttura a lungo termine, una struttura narrativa, avente inizio svolgimento e fine, propria invece di qualsiasi genere musicale. \\
Non è presente nemmeno il classico schema delle canzoni pop: \\
\textit{verso-ritornello-verso-ritornello-bridge-ritornello}. \\
\\
Per ovviare a questo difetto si procedere con un'operazione naive ma efficace: \\
Si decide di generare una nuova sequenza, chiamata \texttt{repeated-melody.mid}, la quale ripete per 4 volte le prime 3 battute prese dal \texttt{best-genome.mid}. \\
La conseguenza risulta essere \textit{ripetitiva} e dunque \textit{intrinsecamente} più regolare, oltre a essere, per il nostro orecchio, più \textit{confortevole}. \\
\\
Abbiamo dunque ottenuto un risultato teorico \textit{accettabile} e \textit{coerente}. \\
Possiamo ottenere di più nella pratica? \\
Si. \\
Importando il file midi (\texttt{repeated-melody.mid}) in una DAW (Digital Audio Workstation, in questo caso è stato utilizzato Ableton) possiamo apportare ulteriori modifiche. \\
Viene assegnata alla traccia lo strumento \textit{Grand Piano}. \\
Su questa vengono applicate le seguenti opzioni

% Inserimento di un'immagine
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{/Users/leonardoangellotti/Desktop/università/terzo anno/tesi/MusicGeneticAlgorithm-main/genetic_music/final results rock/results/ableton_settings} 
    \label{fig:immagine12}
\end{figure}

\textit{MinorTim} permette di generare più note, ad una certa distanza in semitoni, partendo dalla nota corrente. \\
Nel caso specifico si costruisce un accordo minore ad ogni nota. \\
Un primo ascolto risulta essere poco piacevole, perché le note generate non considerano la scala di riferimento. \\
È necessario dunque usare lo strumento \textit{Minor} per ancorare ogni nota in una posizione coerente. \\
Il risultato è decisamente più armonico, seppur tuttavia ancor troppo \textit{piatto} con nessuna variazione nell'esecuzione. \\
Per far fronte a questa \textit{freddezza} ed aumentare la dinamicità, è possibile randomizzare in modo automatico, i valori di velocity nella sequenza per ciascuna nota. \\
Un nuovo ascolto ci rimanda ad un qualche compositore jazz, immerso nel suo fiume di sentimenti,  che vuole mantenere, per piacere della clientela, un ritmo e melodia regolari. \\
\\
Per rendere il risultato ancor più gradevole, e musicalmente completo, possiamo aggiungere un elemento percussivo, come una batteria. \\
Per il risultato ottenuto è stato utilizzato il plug-in \href{https://magenta.tensorflow.org/studio}{Magenta}  sviluppato da Google e attualmente disponibile gratuitamente. \\
In particolare è stata utilizzata la funzione \texttt{Drumify}, che data una sequenza di note, genera un secondo file MIDI in cui, similmente per il piano, vengono indicate le parti della batteria da percuotere (piatto, charleston, gran cassa, rullante). \\
In particolare, nel risultato finale, quest'ultima sequenza MIDI è stata processata dal Plugin \href{https://www.toontrack.com/product/superior-drummer-3/?gad_source=1&gclid=Cj0KCQjws560BhCuARIsAHMqE0H2FsGI5sBj5JLtPNhhiKiLf9qMEccOntk8F9uc4_ZvSDPK5TCZZKUaAg1LEALw_wcB}{SuperiorDrummer3},
una libreria sofisticata che raccoglie suoni di batteria accurati. \\
Si vuole far notare, che l'algoritmo implementato in \texttt{Drumify}, si basa su una neural network, non è di tipo genetico, come nel caso del nostro esempio, in grado dunque di cogliere e sviluppare una certa consequenzialità tra parti. \\
\\
Infine, per le basse frequenze è stata aggiunta una semplice linea di basso, trasponendo la melodia due ottave inferiori, eliminando a mano, secondo il propio gusto, le note ridondanti, lasciando invece quelle fondamentali e di maggiore durata. \\
Il risultato finale, nello specifico, è \textit{quasi accettabile}, considerando che per generarlo sono state necessarie poco più di 500 linee di codice (commenti inclusi) e qualche plugin dal mondo di internet. \\
Il tratto fondamentale risiede nel fatto che per ottenere un file mp3, non abbiamo mai: né dovuto suonare un pianoforte, pizzicare un basso o ritmare una batteria a tempo. \\
\\
Si possono sperimentare ulteriori modifiche, cambiando i pesi (\texttt{smoothnessWeight, restWeight, harmonyWeight}) o implementando un sistema nell'assegnazione della durata e velocity nelle note, ora affidate ad array con valori prefissati (rock, jazz, dance, bossa nova) e ad una scelta random rispettivamente.

\chapter{Conclusioni}
Negli ultimi decenni, la ricerca sulla generazione musicale ha compiuto enormi progressi nella generazione di aspetti ben definiti della musica, come la melodia, l’armonia, il ritmo e il timbro. \\
Modelli statistici all’avanguardia, tecniche di ottimizzazione avanzate, database digitali più grandi su cui addestrare i modelli, e l’aumento della potenza di calcolo, hanno portato alla produzione di sistemi accurati. \\
\\
\textit{Perché allora non utilizziamo sistemi di generazione musicale nella nostra vita quotidiana?} \\
\\
L’indagine di cui sopra mostra che rimane un’importante sfida generale: quella di creare musica con una struttura a lungo termine. \\
Per rendere i sistemi musicali generati dal computer parte della nostra vita quotidiana, c’è bisogno di sistemi più \textit{narrativi}, in grado cioè di creare un inizio, sviluppo e conclusione nella musica. \\

Esiste un potenziale reale affinché il lavoro futuro si sposti verso sistemi intelligenti che non richiedano abbondanti quantità di tracce audio, o sequenze musicali, 
ma che siano capaci di un ragionamento innato, rispecchiando il funzionamento della mente umana. \\
Ciò risolverebbe anche la continua sfida di trovare un equilibrio tra la rigenerazione della musica esistente, o frammenti di questa senza ricadere nel plagio. \\
\\
% Esempio di citazione
Come descritto da Lamport \cite{latex}, e come discusso da Doe e Smith \cite{example_article}, i metodi utilizzati sono basati su...

% Bibliografia
\bibliographystyle{plain}
\bibliography{bibliografia}

\end{document}
